String.prototype.substring = function (start, end) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(start);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    if (end === undefined || end > this.length) {
        end = this.length;
    }
    if (end < start) {
        var temp = end;
        end = start;
        start = temp;
    }
    var retval = "";
    for (; start < end; start++) {
        retval += this.charAt(start);
    }
    return retval;
};

function foldl(f, initial, seq) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(f);
    //print(failed);
    //print(foldl);
    //print(initial);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(seq);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    for (var i = 0; i < seq.length; ++i) initial = f(initial, seq[i]);
    return initial;
}

var memoize = true;

function ParseState(input, index) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(index);
    //print(input);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    this.input = input;
    this.index = index || 0;
    this.length = input.length - this.index;
    this.cache = {};
}

ParseState.prototype.from = function (index) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(index);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var r = new ParseState(this.input, this.index + index);
    r.cache = this.cache;
    r.length = this.length - index;
    return r;
};

ParseState.prototype.substring = function (start, end) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(start);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return this.input.substring(start + this.index, (end || this.length) + this.index);
};

function numLeadingWhitespace(str) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(str);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    function isWhitespace(c) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(c);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(isWhitespace);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(numWhitespace);
        //print(optional);
        //print(parser_id);
        //print(passed);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(str);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(x);
        //print(xor);
        return c == " " || c == "	" || c == "\n" || c == "" || c == "\f" || c == "\r";
    }

    var numWhitespace = 0;
    for (var x = 0; x < str.length; x++) {
        if (!isWhitespace(str.charAt(x))) {
            break;
        } else {
            numWhitespace++;
        }
    }
    return numWhitespace;
}

ParseState.prototype.trimLeft = function () {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var s = this.substring(0);
    var c = s.charAt(0);
    var m = numLeadingWhitespace(s);
    return m > 0 ? this.from(m) : this;
};

ParseState.prototype.at = function (index) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(index);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return this.input.charAt(this.index + index);
};

ParseState.prototype.getCached = function (pid) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(pid);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    if (!memoize) return false;
    var p = this.cache[pid];
    if (p) return p[this.index]; else return false;
};

ParseState.prototype.putCached = function (pid, cached) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(cached);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(pid);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    if (!memoize) return false;
    var p = this.cache[pid];
    if (p) p[this.index] = cached; else {
        p = this.cache[pid] = {};
        p[this.index] = cached;
    }
};

function ps(str) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(str);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return new ParseState(str);
}

function make_result(r, matched, ast) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(ast);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(matched);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(r);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return {
        remaining: r,
        matched: matched,
        ast: ast
    };
}

var parser_id = 0;

function token(s) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(s);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(s);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) {
            return cached;
        }
        var r = state.length >= s.length && state.substring(0, s.length) == s;
        if (r) {
            cached = {
                remaining: state.from(s.length),
                matched: s,
                ast: s
            };
        } else {
            cached = false;
        }
        savedState.putCached(pid, cached);
        return cached;
    };
}

function ch(c) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(c);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(c);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        var r = state.length >= 1 && state.at(0) == c;
        if (r) cached = {
            remaining: state.from(1),
            matched: c,
            ast: c
        }; else cached = false;
        savedState.putCached(pid, cached);
        return cached;
    };
}

function range(lower, upper) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(lower);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(upper);
    //print(whitespace);
    //print(xor);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(lower);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(upper);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        if (state.length < 1) cached = false; else {
            var ch = state.at(0);
            if (ch >= lower && ch <= upper) cached = {
                remaining: state.from(1),
                matched: ch,
                ast: ch
            }; else cached = false;
        }
        savedState.putCached(pid, cached);
        return cached;
    };
}

function toParser(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return typeof p == "string" ? token(p) : p;
}

function whitespace(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) {
            return cached;
        }
        var trimmed = state.trimLeft();
        cached = p(trimmed);
        savedState.putCached(pid, cached);
        return cached;
    };
}

function action(p, f) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(f);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(f);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        var x = p(state);
        if (x) {
            x.ast = f(x.ast);
            cached = x;
        } else {
            cached = false;
        }
        savedState.putCached(pid, cached);
        return cached;
    };
}

function join_action(p, sep) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sep);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return action(p, function (ast) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(ast);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sep);
        //print(sequence);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        return ast.join(sep);
    });
}

function left_factor(ast) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(ast);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return foldl(function (v, action) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(ast);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(parser_id);
        //print(passed);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(toParser);
        //print(token);
        //print(v);
        //print(whitespace);
        //print(xor);
        return [v, action];
    }, ast[0], ast[1]);
}

function left_factor_action(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return action(p, left_factor);
}

function negate(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        if (state.length >= 1) {
            var r = p(state);
            if (!r) cached = make_result(state.from(1), state.at(0), state.at(0)); else cached = false;
        } else {
            cached = false;
        }
        savedState.putCached(pid, cached);
        return cached;
    };
}

function end_p(state) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(state);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    if (state.length == 0) return make_result(state, undefined, undefined); else return false;
}

function nothing_p(state) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(state);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return false;
}

function sequence() {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var parsers = [];
    for (var i = 0; i < arguments.length; ++i) parsers.push(toParser(arguments[i]));
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(i);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(parser_id);
        //print(parsers);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) {
            return cached;
        }
        var ast = [];
        var matched = "";
        var i;
        for (i = 0; i < parsers.length; ++i) {
            var parser = parsers[i];
            var result = parser(state);
            if (result) {
                state = result.remaining;
                if (result.ast != undefined) {
                    ast.push(result.ast);
                    matched = matched + result.matched;
                }
            } else {
                break;
            }
        }
        if (i == parsers.length) {
            cached = make_result(state, matched, ast);
        } else cached = false;
        savedState.putCached(pid, cached);
        return cached;
    };
}

function choice() {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var parsers = [];
    for (var i = 0; i < arguments.length; ++i) parsers.push(toParser(arguments[i]));
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(i);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(parser_id);
        //print(parsers);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) {
            return cached;
        }
        var i;
        for (i = 0; i < parsers.length; ++i) {
            var parser = parsers[i];
            var result = parser(state);
            if (result) {
                break;
            }
        }
        if (i == parsers.length) cached = false; else cached = result;
        savedState.putCached(pid, cached);
        return cached;
    };
}

function butnot(p1, p2) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p1);
    //print(p2);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p1 = toParser(p1);
    p2 = toParser(p2);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p1);
        //print(p2);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        var br = p2(state);
        if (!br) {
            cached = p1(state);
        } else {
            var ar = p1(state);
            if (ar) {
                if (ar.matched.length > br.matched.length) cached = ar; else cached = false;
            } else {
                cached = false;
            }
        }
        savedState.putCached(pid, cached);
        return cached;
    };
}

function difference(p1, p2) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p1);
    //print(p2);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p1 = toParser(p1);
    p2 = toParser(p2);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p1);
        //print(p2);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        var br = p2(state);
        if (!br) {
            cached = p1(state);
        } else {
            var ar = p1(state);
            if (ar.matched.length >= br.matched.length) cached = br; else cached = ar;
        }
        savedState.putCached(pid, cached);
        return cached;
    };
}

function xor(p1, p2) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p1);
    //print(p2);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p1 = toParser(p1);
    p2 = toParser(p2);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p1);
        //print(p2);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        var ar = p1(state);
        var br = p2(state);
        if (ar && br) cached = false; else cached = ar || br;
        savedState.putCached(pid, cached);
        return cached;
    };
}

function repeat0(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) {
            return cached;
        }
        var ast = [];
        var matched = "";
        var result;
        while (result = p(state)) {
            ast.push(result.ast);
            matched = matched + result.matched;
            if (result.remaining.index == state.index) break;
            state = result.remaining;
        }
        cached = make_result(state, matched, ast);
        savedState.putCached(pid, cached);
        return cached;
    };
}

function repeat1(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        var ast = [];
        var matched = "";
        var result = p(state);
        if (!result) cached = false; else {
            while (result) {
                ast.push(result.ast);
                matched = matched + result.matched;
                if (result.remaining.index == state.index) break;
                state = result.remaining;
                result = p(state);
            }
            cached = make_result(state, matched, ast);
        }
        savedState.putCached(pid, cached);
        return cached;
    };
}

function optional(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        var r = p(state);
        cached = r || make_result(state, "", false);
        savedState.putCached(pid, cached);
        return cached;
    };
}

function expect(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return action(p, function (ast) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(ast);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        return undefined;
    });
}

function chain(p, s, f) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(f);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(s);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    return action(sequence(p, repeat0(action(sequence(s, p), f))), function (ast) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(ast);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(f);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(s);
        //print(semantic);
        //print(sequence);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        return [ast[0]].concat(ast[1]);
    });
}

function chainl(p, s) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(s);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    return action(sequence(p, repeat0(sequence(s, p))), function (ast) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(ast);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(s);
        //print(semantic);
        //print(sequence);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        return foldl(function (v, action) {
            //print(ParseState);
            //print(ParserTests);
            //print(action);
            //print(and);
            //print(assertEqual);
            //print(assertFalse);
            //print(assertFullyParsed);
            //print(assertNotEqual);
            //print(assertParseFailed);
            //print(assertParseMatched);
            //print(assertTrue);
            //print(ast);
            //print(butnot);
            //print(ch);
            //print(chain);
            //print(chainl);
            //print(choice);
            //print(difference);
            //print(end_p);
            //print(epsilon_p);
            //print(expect);
            //print(failed);
            //print(foldl);
            //print(join_action);
            //print(left_factor);
            //print(left_factor_action);
            //print(list);
            //print(make_result);
            //print(memoize);
            //print(negate);
            //print(not);
            //print(nothing_p);
            //print(numLeadingWhitespace);
            //print(optional);
            //print(p);
            //print(parser_id);
            //print(passed);
            //print(ps);
            //print(range);
            //print(repeat0);
            //print(repeat1);
            //print(runTests);
            //print(s);
            //print(semantic);
            //print(sequence);
            //print(toParser);
            //print(token);
            //print(v);
            //print(whitespace);
            //print(xor);
            return action[0](v, action[1]);
        }, ast[0], ast[1]);
    });
}

function list(p, s) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(s);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return chain(p, s, function (ast) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(ast);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(s);
        //print(semantic);
        //print(sequence);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        return ast[1];
    });
}

function epsilon_p(state) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(state);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    return make_result(state, "", undefined);
}

function semantic(f) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(f);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(f);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        cached = f() ? make_result(state, "", undefined) : false;
        savedState.putCached(pid, cached);
        return cached;
    };
}

function and(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        var r = p(state);
        cached = r ? make_result(state, "", undefined) : false;
        savedState.putCached(pid, cached);
        return cached;
    };
}

function not(p) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(p);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    p = toParser(p);
    var pid = parser_id++;
    return function (state) {
        //print(ParseState);
        //print(ParserTests);
        //print(action);
        //print(and);
        //print(assertEqual);
        //print(assertFalse);
        //print(assertFullyParsed);
        //print(assertNotEqual);
        //print(assertParseFailed);
        //print(assertParseMatched);
        //print(assertTrue);
        //print(butnot);
        //print(ch);
        //print(chain);
        //print(chainl);
        //print(choice);
        //print(difference);
        //print(end_p);
        //print(epsilon_p);
        //print(expect);
        //print(failed);
        //print(foldl);
        //print(join_action);
        //print(left_factor);
        //print(left_factor_action);
        //print(list);
        //print(make_result);
        //print(memoize);
        //print(negate);
        //print(not);
        //print(nothing_p);
        //print(numLeadingWhitespace);
        //print(optional);
        //print(p);
        //print(parser_id);
        //print(passed);
        //print(pid);
        //print(ps);
        //print(range);
        //print(repeat0);
        //print(repeat1);
        //print(runTests);
        //print(semantic);
        //print(sequence);
        //print(state);
        //print(toParser);
        //print(token);
        //print(whitespace);
        //print(xor);
        var savedState = state;
        var cached = savedState.getCached(pid);
        if (cached) return cached;
        cached = p(state) ? false : make_result(state, "", undefined);
        savedState.putCached(pid, cached);
        return cached;
    };
}

var passed = [];

var failed = [];

function assertTrue(msg, test) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(msg);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(test);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    if (test) passed.push(msg); else failed.push(msg);
}

function assertFalse(msg, test) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(msg);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(test);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    if (test) failed.push(msg); else passed.push(msg);
}

function assertEqual(msg, value1, value2) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(msg);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(value1);
    //print(value2);
    //print(whitespace);
    //print(xor);
    if (value1 == value2) passed.push(msg); else failed.push(msg);
}

function assertNotEqual(msg, value1, value2) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(msg);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(value1);
    //print(value2);
    //print(whitespace);
    //print(xor);
    if (value1 != value2) passed.push(msg); else failed.push(msg);
}

function assertFullyParsed(parser, string) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(string);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var msg = " did not fully parse: " + string;
    try {
        var result = parser(ps(string));
        if (result && result.remaining.length == 0) passed.push(msg); else failed.push(msg);
    } catch (e) {
        failed.push(msg);
    }
}

function assertParseFailed(parser, string) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(string);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var msg = " succeeded but should have failed: " + string;
    try {
        var result = parser(ps(string));
        if (!result) passed.push(msg); else failed.push(msg);
    } catch (e) {
        failed.push(msg);
    }
}

function assertParseMatched(parser, string, expected) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(expected);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(string);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    var msg = " parse did not match: " + string;
    try {
        var result = parser(ps(string));
        if (result && result.matched == expected) passed.push(msg); else failed.push(msg + " got [" + result.matched + "] expected [" + expected + "]");
    } catch (e) {
        failed.push(msg);
    }
}

function runTests(func) {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(func);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    passed = [];
    failed = [];
    func();
    var total = passed.length + failed.length;
    for (var i = 0; i < failed.length; ++i) print(failed[i]);
    print(total + " tests: " + passed.length + " passed, " + failed.length + " failed");
}

function ParserTests() {
    //print(ParseState);
    //print(ParserTests);
    //print(action);
    //print(and);
    //print(assertEqual);
    //print(assertFalse);
    //print(assertFullyParsed);
    //print(assertNotEqual);
    //print(assertParseFailed);
    //print(assertParseMatched);
    //print(assertTrue);
    //print(butnot);
    //print(ch);
    //print(chain);
    //print(chainl);
    //print(choice);
    //print(difference);
    //print(end_p);
    //print(epsilon_p);
    //print(expect);
    //print(failed);
    //print(foldl);
    //print(join_action);
    //print(left_factor);
    //print(left_factor_action);
    //print(list);
    //print(make_result);
    //print(memoize);
    //print(negate);
    //print(not);
    //print(nothing_p);
    //print(numLeadingWhitespace);
    //print(optional);
    //print(parser_id);
    //print(passed);
    //print(ps);
    //print(range);
    //print(repeat0);
    //print(repeat1);
    //print(runTests);
    //print(semantic);
    //print(sequence);
    //print(toParser);
    //print(token);
    //print(whitespace);
    //print(xor);
    assertFullyParsed(token("a"), "a");
    assertFullyParsed(token("abcd"), "abcd");
    assertParseMatched(token("abcd"), "abcdef", "abcd");
    assertParseFailed(token("a"), "b");
    assertParseMatched(ch("a"), "abcd", "a");
    assertParseFailed(ch("a"), "bcd");
    for (var i = 0; i < 10; ++i) {
        assertParseMatched(range("0", "9"), "" + i, i);
    }
    assertParseFailed(range("0", "9"), "a");
    assertFullyParsed(token("ab"), "ab");
    assertFullyParsed(whitespace(token("ab")), "ab");
    assertFullyParsed(whitespace(token("ab")), " ab");
    assertFullyParsed(whitespace(token("ab")), "  ab");
    assertFullyParsed(whitespace(token("ab")), "   ab");
    assertFullyParsed(negate(ch("a")), "b");
    assertParseFailed(negate(ch("a")), "a");
    assertParseFailed(end_p, "ab");
    assertFullyParsed(end_p, "");
    assertParseFailed(nothing_p, "abcd");
    assertParseFailed(nothing_p, "");
    assertFullyParsed(sequence("a", "b"), "ab");
    assertParseFailed(sequence("a", "b"), "b");
    assertParseFailed(sequence("a", "b"), "a");
    assertParseMatched(sequence("a", whitespace("b")), "a b", "ab");
    assertParseMatched(sequence("a", whitespace("b")), "a  b", "ab");
    assertParseMatched(sequence("a", whitespace("b")), "ab", "ab");
    assertFullyParsed(choice("a", "b"), "a");
    assertFullyParsed(choice("a", "b"), "b");
    assertParseMatched(choice("a", "b"), "ab", "a");
    assertParseMatched(choice("a", "b"), "bc", "b");
    assertParseMatched(repeat0(choice("a", "b")), "adef", "a");
    assertParseMatched(repeat0(choice("a", "b")), "bdef", "b");
    assertParseMatched(repeat0(choice("a", "b")), "aabbabadef", "aabbaba");
    assertParseMatched(repeat0(choice("a", "b")), "daabbabadef", "");
    assertParseMatched(repeat1(choice("a", "b")), "adef", "a");
    assertParseMatched(repeat1(choice("a", "b")), "bdef", "b");
    assertParseMatched(repeat1(choice("a", "b")), "aabbabadef", "aabbaba");
    assertParseFailed(repeat1(choice("a", "b")), "daabbabadef");
    assertParseMatched(sequence("a", optional(choice("b", "c")), "d"), "abd", "abd");
    assertParseMatched(sequence("a", optional(choice("b", "c")), "d"), "acd", "acd");
    assertParseMatched(sequence("a", optional(choice("b", "c")), "d"), "ad", "ad");
    assertParseFailed(sequence("a", optional(choice("b", "c")), "d"), "aed");
    assertParseFailed(sequence("a", optional(choice("b", "c")), "d"), "ab");
    assertParseFailed(sequence("a", optional(choice("b", "c")), "d"), "ac");
    assertParseMatched(list(choice("1", "2", "3"), ","), "1,2,3", "1,2,3");
    assertParseMatched(list(choice("1", "2", "3"), ","), "1,3,2", "1,3,2");
    assertParseMatched(list(choice("1", "2", "3"), ","), "1,3", "1,3");
    assertParseMatched(list(choice("1", "2", "3"), ","), "3", "3");
    assertParseFailed(list(choice("1", "2", "3"), ","), "5,6,7");
    assertParseMatched(sequence(and("0"), "0"), "0", "0");
    assertParseFailed(sequence(and("0"), "1"), "0");
    assertParseMatched(sequence("1", and("2")), "12", "1");
    assertParseMatched(sequence("a", choice("+", "++"), "b"), "a+b", "a+b");
    assertParseFailed(sequence("a", choice("+", "++"), "b"), "a++b");
    assertParseMatched(sequence("a", choice(sequence("+", not("+")), "++"), "b"), "a+b", "a+b");
    assertParseMatched(sequence("a", choice(sequence("+", not("+")), "++"), "b"), "a++b", "a++b");
    assertFullyParsed(butnot(range("0", "9"), "6"), "1");
    assertParseFailed(butnot(range("0", "9"), "6"), "6");
    assertParseFailed(butnot(range("0", "9"), "x"), "x");
    assertParseFailed(butnot(range("0", "9"), "y"), "x");
}

runTests(ParserTests);

//print(ParseState);

//print(ParserTests);

//print(action);

//print(and);

//print(assertEqual);

//print(assertFalse);

//print(assertFullyParsed);

//print(assertNotEqual);

//print(assertParseFailed);

//print(assertParseMatched);

//print(assertTrue);

//print(butnot);

//print(ch);

//print(chain);

//print(chainl);

//print(choice);

//print(difference);

//print(end_p);

//print(epsilon_p);

//print(expect);

//print(failed);

//print(foldl);

//print(join_action);

//print(left_factor);

//print(left_factor_action);

//print(list);

//print(make_result);

//print(memoize);

//print(negate);

//print(not);

//print(nothing_p);

//print(numLeadingWhitespace);

//print(optional);

//print(parser_id);

//print(passed);

//print(ps);

//print(range);

//print(repeat0);

//print(repeat1);

//print(runTests);

//print(semantic);

//print(sequence);

//print(toParser);

//print(token);

//print(whitespace);

print(xor);